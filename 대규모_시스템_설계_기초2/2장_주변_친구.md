# 주변친구

  주변 친구 기능은 인근의 친구 목록을 보여주는 시스템입니다. 1장의 근접성 서비스와 다른 점은, 사업장 주소가 정적이었다면 주변 친구 위치는 자주 바뀔 수 있다는 점입니다.

# 개략적인 설계

  가장 간단한 설계는 백엔드 시스템에서 모든 활성 상태 사용자의 위치 변화 내역을 수신한 다음, 해당 정보를 모든 활성 상태 친구를 찾아서 전달하는 것입니다.

![image-20240416220649773](images/2장_주변_친구/image-20240416220649773.png)

  하지만 사용자가 천만 명 이상으로 많다면 위치 갱신 요청과 전송이 엄청나게 많아집니다.

## 소규모 백엔드를 위한 개략적 설계

![image-20240416220951972](images/2장_주변_친구/image-20240416220951972.png)

  우선 소규모 서버를 위한 설계안부터 보자면, 웹소켓 서버와 API 서버를 따로 운용합니다. 웹소켓 서버는 레디스 위치 정보 캐시를 이용해서 가장 최근 위치 정보를 캐시합니다. 또한 레디스 pub/sub 서버로 수백만 개의 채널을 생성할 수 있습니다.

  사용자는 주기적으로 위치를 웹소켓 서버로 보내며, 레디스 pub/sub, 위치정보 캐시, 위치 이동 이력 DB 를 병렬적으로 업데이트합니다. 그리고 레디스 채널을 구독하고 있는 친구들은 자신의 위치와 상대방의 위치를 계산해 검색 반경 내라면 구독자의 클라이언트 앱으로 전송합니다.

## 데이터 모델

  위치 정보 캐시는 레디스가 가장 적합합니다. 읽기 쓰기 연산 속도가 엄청 빠르고 TTL 도 지원하기 때문입니다. 또한 위치 정보는 영속성을 보장할 필요도 없습니다. 다른 서버로 바꾼 다음 갱신된 위치 정보가 캐시에 채워지기를 기다리면 되기 때문입니다.

> 비용 문제는 없는지? -> 수 GB 면 문제없을 듯

​    위치 이동 이력 DB 는 user_id, latitude, longitude, timestamp 를 저장하는 테이블이 필요합니다. 높은 쓰기 부하와 수평적 규모 확장이 가능한 DB 이어야 하므로 카사느라가 부합합니다. 관계형 DB 를 사용할 수도 있으나 규모가 커지면 샤딩이 필요합니다.

> 의문 : 위치 정보 캐시에 꼭 레디스를 사용해야 하는가?

# 상세 설계

**웹소켓 서버**

  웹소켓 서버 규모를 자동으로 늘리는 건 어렵지 않으나 노드를 제거하기 전에 우선 기존 연결이 종료될 수 있도록 해야 합니다. 로드 밸런서가 인식하는 노드 상태를 draining 으로 변경하여 새로운 웹소켓 연결이 만들어지지 않도록 합니다.

**클라이언트 초기화**

  웹소켓 연결이 초기화되면 클라이언트는 해당 사용자의 위치 정보를 전송합니다. 그 정보를 받은 웹소켓 연결 핸들러는 위치 정보 캐시의 위치를 갱신한 다음 사용자 DB 에서 모든 친구 정보를 가져옵니다. 해당 정보를 통해 위치 정보 캐시에서 모든 친구의 위치를 한번에 가져옵니다. 캐시의 TTL 은 비활성화 타임아웃 시간과 동일한 값이므로 비활성화 친구의 위치는 캐시에 없습니다. 그리고 위치 정보를 바탕으로 거리를 검색하고 검색 반경 이내이면 클라이언트에게 반환합니다.

**사용자 데이터베이스** 

  사용자 DB 에는 사용자의 상세 정보와 친구 관계 데이터가 포함됩니다. 이런 데이터는 한 대로 관리하기에 매우 크지만, 사용자 ID 를 기준으로 샤딩할 수 있습니다.

**위치 정보 캐시**

  위치 정보에 100바이트가 필요하다고 가정할 때 수 GB 이상의 메모리로 모든 위치 정보를 캐시할 수 있습니다. 하지만 천만 명의 활성 사용자가 30초마다 위치 정보를 전송하면 레디스 서버는 초당 334,000번의 연산이 필요한데, 이는 사용자 ID 를 기준으로 샤딩을 해서 고르게 분산할 수 있습니다.

**레디스 펍/섭 서버**

  레디스 펍/섭은 채널을 만드는 비용이 아주 저렴합니다. 구독자가 없는 채널로 전송된 메시지는 그대로 버려지는데, 그 과정에서 서버 부하가 거의 없습니다.

- 메모리 사용량 : 모든 사용자가 하나의 채널을 사용한다고 하면 필요한 채널 수는 1억 개입니다. 한 사용자의 활성화 상태 친구 가운데 100명이 주변 친구 기능을 사용한다고 하고, 추적을 위해 내부적으로 해시 테이블과 연결 리스트에 20 바이트를 저장한다고 가정합니다. 그러면 모든 채널을 저장하는 데 200GB 의 메모리가 필요합니다.
- CPU 사용량 : 레디스의 초당 업데이트 양은 1400만 건입니다. 보수적으로 계산해서 서버 한 대로 감당 가능한 구독자 수는 100,000 이라고 가정한다면 필요한 서버는 140대입니다. 따라서 레디스 펍/섭 서버의 병목은 CPU 사용량이 됩니다.

**분산 레디스 펍/섭 서버 클러스터**

  모든 채널은 독립적이므로 사용자 ID 를 기준으로 펍/섭 서버들을 샤딩하면 됩니다. 웹소켓은 메시지를 발행할 레디스 펍/섭 서버를 선정한 후 해당 서버가 관리하는 사용자 채널에 위치 정보 변경 내역을 발행합니다.

  레디스 펍/섭 서버는 데이터를 저장하지는 않지만, 각 채널의 구독자가 해당 서버 내의 채널을 구독하기 때문에 유상태 서버 클러스터로 취급해야 합니다. 따라서 규모를 늘리거나 줄이는 건 운영 부담과 위험이 큽니다. 클러스터 크기를 조정하려면 아래와 같은 절차대로 진행합니다.

- 새로운 링크기 계산
- 해시 링의 키에 매달린 값을 새로운 내용으로 갱신
- 대시보드 모니터링 -> 웹소켓 클러스터의 CPU 사용량이 어느 정도 튀어야 함

**친구 추가 / 삭제**

  친구가 추가되면 웹소켓 서버의 연결 핸들러에 그 사실을 알리고 새 친구의 펍/섭 채널을 구독하야 합니다. 마찬가지로 친구가 삭제되면 펍/섭 채널 구독을 취소합니다.

**친구가 많은 사용자**

  친구가 수천 명이 있을 때, 해당 친구들을 구독하는 데 필요한 채널들은 많은 웹소켓 서버에 분산되어있어서 문제되지 않습니다. 해당 사용자 채널이 존재하는 서버는 조금 더 많은 부하가 있겠지만, 그러한 헤비 유저들의 채널들이 모든 펍/섭 서버에 분산되므로 특정 서버가 많은 부담을 받지는 않습니다.







