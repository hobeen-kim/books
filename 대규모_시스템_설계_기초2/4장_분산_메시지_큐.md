> 메시지 큐 vs 이벤트트 스트리밍 플래폼
>
>   아파치 카프ㅏ나 펄사는 이벤트 스트리밍 플랫폼이지만 메시지큐와 지원하는 기능이 서로 수렴하면서 차이가 희미해지고 있음

# 요구사항

- 메시지는 반복적으로 수신할 수도 있어야 하고, 단 한번만 수신하도록 설정될 수도 있어야 한다.
- 오래된 이력 데이터는 삭제될 수 있다.
- 메시지 크기는 킬로바이트 수준이다.
- 메시지가 생산된 순서대로 소비자에게 전달할 수 있어야 한다.
- 메시지 전달 방식은 최소 한 번, 최대 한 번, 정확히 한 번 가운데 설정할 수 있어야 한다.

# 개략적인 설계안

## 메시지 모델

  가장 널리 사용되는 건 일대일(point-to-point) 와 발행-구독(publish-subscribe) 모델입니다.

### 일대일 모델

  메시지는 오직 한 소비자만 가져갈 수 있습니다.

### 발행-구독 모델

  해당 모델에서는 토픽 개념이 필요합니다. 해당 토픽을 구독하고 있는 서비스는 토픽의 메시지를 모두 받을 수 있습니다. 토픽에 보관되는 데이터 양이 많아지면 파티션을 통해 토픽을 여러 파티션으로 분할한 다음 보관합니다. 파티션을 유지하는 서버를 브로커라고 부릅니다.

## 개략적인 설계안

![image-20240423200856840](images/4장_분산_메시지_큐/image-20240423200856840.png)

- 클라이언트
  - 생산자 : 메시지를 특정 토픽으로 보냄
  - 소비자 그룹 : 토픽을 구독하고 메시지를 소비
- 브로커 : 파티션을 유지
- 저장소
  - 데이터 저장소 : 메시지는 파티션 내 데이터 저장소에 보관됨
  - 상태 저장소 : 소비자 상태는 이 저장소에 유지됨
  - 메타데이터 저장소 : 토픽 설정, 토픽 속성 등을 저장
- 조정 서비스
  - 서비스 탐색 : 어떤 브로커가 살아있는지 알려줌
  - 리더 선출 : 브로커 가운데 하나는 컨트롤러 역할을 담당해야 하며, 한 클러스터에는 반드시 활성 상태 컨트롤러가 하나 있어야 함. 이 컨트롤러가 파티션 배치를 책임짐
  - 아파치 주키퍼나 etcd 가 보통 컨트롤러 선출을 담당하는 컴포넌트로 이용됨

# 상세 설계

## 데이터 저장소

  데이터에 대한 읽기/쓰기는 빈번하게 일어나지만 갱신/삭제는 발생하지 않습니다. 그리고 순차적인 읽기/쓰기가 대부분입니다. 데이터베이스는 읽기/쓰기가 동시에 대규모로 빈번하게 발생하는 상황을 잘 처리하지 못합니다.

  쓰기 우선 로그 (Write-Ahead Log, WAL) 는 새로운 항목이 추가되기만 하는(append-only) 일반 파일입니다. WAL 에 대한 접근 패턴은 읽기/쓰기 모두 순차적이므로 회전식 디스크에서 아주 좋은 성능을 보입니다. 하나의 파일의 크기가 무한정 커질 수 없으므로 세크먼트 단위로 나눠서 관리할 수 있습니다.

![image-20240423213447305](images/4장_분산_메시지_큐/image-20240423213447305.png)

  회전식 디스크는 데이터 접근 패턴이 무작위일 때 느리며, 순차적 데이터 접근 시 수백 MB/sec 수준의 읽기/쓰기 성능을 달성할 수 있습니다.

## 메시지 자료 구조

  메시지가 큐를 거쳐 소비자에게 전달되는 과정에서 불필요한 복사가 일어나면 안됩니다. 시스템 컴포넌트는 해당 구조를 그대로 받아들여야 하며 그러지 못하면 값비싼 복사가 발생하게 됩니다.