  이벤트 기반 아키턱처는 확장성이 뛰어난 고성능 애플리케이션 개발에 널리 쓰이는 비동기 분산 아키텍처 스타일입니다.

# 1. 토폴로지

> 토폴리지
>
> ??

  주요 토폴로지로는 중재자 토폴로지와 브로커 토폴로지가 있습니다. 중재자 토폴로지는 이벤트 처리 워크플로를 제어해야 할 경우에, 브로커 토폴로지는 신속한 응답과 동적인 이벤트 처리 제어가 필요할 때 각각 사용됩니다.

## 1.2 브로커 토폴로지

  브로커 토폴로지는 시작 이벤트, 이벤트 브로커, 이벤트 프로세서, 처리 이벤트 컴포넌트로 구성됩니다. 브로커 토폴로지에는 중재자가 없으므로 이벤트 프로세서는 이벤트 브로커에서 시작 이벤트를 받아서 처리 작업을 마친 뒤 처리 이벤트를 생성하고, 시스템의 나머지 부분에 자신이 한 일을 비동기로 알립니다.

![image-20240218201559175](images/14장 이벤트 기반 아키텍처 스타일/image-20240218201559175.png)

 이벤트 브로커 컴포넌트는 클러스터링된 다수의 인스턴스로 구성되어 모든 이벤트 채널이 들어 있습니다. 브로커 토폴리지에서 다른 이벤트 프로세서의 관심 여부와 무관하게 각 이벤트 프로세서가 자신이 한 일을 모두에게 알리는 게 확장성 측면에서 바람직합니다. 해당 이벤트에 아무도 관심없더라도, 나중에 해당 처리 이벤트를 사용할 일이 있을 수 있기 때문입니다.

  브로커 토폴로지는 성능, 응답성, 확장성 측면에서 장점이 많지만 단점도 적지 않습니다. 시작 이벤트와 연관된 전체 워크플로를 제어할 수가 없으며 에러 처리 역시 어렵습니다. 그리고 하나의 처리가 실패해도 다른 파트는 그 사실을 알지 못합니다. 

![image-20240218201940979](images/14장 이벤트 기반 아키텍처 스타일/image-20240218201940979.png)

## 1.2 중재자 토폴로지

  중재자 이벤트는 브로커 토폴로지의 단점을 일부 보완합니다. 여러 이벤트 프로세서 간 조정이 필요한 시작 이벤트에 대해 워크플로를 관리/제어하는 이벤트 중재자가 핵심입니다. 중재자 토폴로지는 **시작 이벤트, 이벤트 큐, 이벤트 중재자, 이벤트 채널, 이벤트 프로세서**, 이렇게 5개 아키텍처 컴포넌트로 구성됩니다.

![image-20240218203701991](images/14장 이벤트 기반 아키텍처 스타일/image-20240218203701991.png)

  이벤트가 발생되면 이벤트 큐를 거쳐 이벤트 중재자로 전달됩니다. 이벤트 중재자는 이벤트 처리에 관한 단계 정보가 있으므로 점대점 메시징으로 각각의 이벤트 채널로 전달되는 처리 이벤트를 생성합니다. 이벤트 프로세서는 이벤트 처리 후 다른 프로세서에게 자신이 한 일을 알리지 않습니다.

![image-20240218210452970](images/14장 이벤트 기반 아키텍처 스타일/image-20240218210452970.png)

  위 그림과 같이 이벤트 복잡도에 따라서 다른 이벤트 중재자로 위임할 수도 있습니다. 하지만 중재자 토폴로지는 복잡한 이벤트 흐름 내에서 발생하는 동적인 처리를 선언적으로 모델링하기가 매우 어렵습니다. 그래서 이러한 부분은 중재자 + 브로커 형태의 하이브리드 모델로 처리합니다. 또한 이벤트 프로세서 확장 시 중재자도 함께 확장해야 하므로 전체 이벤트 처리 흐름에 병목 지점이 생기기 쉽습니다. 그리고 이벤트 처리를 중재자가 제어하므로 이벤트 프로세서가 상대적으로 더 많이 커플링되어 성능은 브로커 토폴로지보다 좋지 안습니다.

![image-20240218211013544](images/14장 이벤트 기반 아키텍처 스타일/image-20240218211013544.png)

# 2. 비동기 통신

  이벤트 기반 아키텍처 스타일은 요청/응답 처리 뿐만 아니라 fire and forget 처리 모두 비동기 통신만 사용합니다. 따라서 시스템 응답성을 전반적으로 높일 수 있습니다. 하지만 비동기 통신 시 에러 또는 예외 처리를 고민해야 하기 때문에 시스템의 복잡도가 가중됩니다.

# 3. 에러 처리

  리액티브 아키텍처의 워크플로 이벤트 패턴은 비동기 워크플로에서 에러 처리 문제를 해결하는 한 가지 방법입니다. 

![image-20240218212101543](images/14장 이벤트 기반 아키텍처 스타일/image-20240218212101543.png)

  컨슈머에서 에러가 발생하면 해당 에러를 직접 처리하지 않고 워크플로 프로세서로 보내고 다음 큐를 계속 처리합니다. 워크플로 프로세서는 에러를 해결하고 원데이터를 변경해서 원래 큐로 보냅니다. 이벤트 컨슈머는 재처리를 시도하는데, 이 때도 계속 실패한다면 워크플로 프로세서는 해당 이벤트를 대시보드에 게시하거나 메일을 보내는 등의 작업을 합니다.

# 4. 데이터 소실 방지

  이벤트 기반 아키텍처에서 비동기 통신 시 데이터가 소실될 만한 곳이 많습니다. 예를 들어 이벤트 프로세서 A 가 큐에 메시지를 비동기로 전송하고 이벤트 프로세서 B 는 이 메시지를 받아 데이터베이스에 삽입한다고 할 때, 데이터 소실이 일어나는 경우는 다음 세 가지가 있습니다.

![image-20240218212957820](images/14장 이벤트 기반 아키텍처 스타일/image-20240218212957820.png)

1. 이벤트 프로세서 A 에서 메시지가 큐로 전달되지 않거나 다음 이벤트 프로세서가 메시지를 가져오기 전에 브로커가 다운됨
2. 이벤트 프로세서 B 가 큐에서 다음 메시지를 꺼내 이벤트를 처리하기 전에 장애 발생
3. 데이터 에러로 인해 이벤트 프로세서 B 가 데이터베이스에 메시지를 저장할 수 없음

  1번 이슈는 동기 전송과 퍼시스턴트 메시지 큐를 이용하여 해결할 수 있습니다. 프로세서가 이벤트 채널에 이벤트를 보내면 응답이 올 때까지 대기합니다. 그리고 브로커는 메모리와 물리적 데이터 저장소에 함께 저장합니다. 그리고 저장이 완료되면 프로세서에 응답을 보냅니다. 이렇게 하면 이벤트가 소실될 일이 없습니다.

  2번 이슈는 클라이언트 확인응답 모드로 해결할 수 있습니다. 원래 메시지는 큐에서 빠져나가는 즉시 삭제되는데, 클라이언트 확인응답 모드는 메시지를 큐에 보관한 채 다른 컨슈머가 메시지를 읽을 수 없게 클라이언트 ID 를 메시지에 부착합니다.

  3번 이슈는 DB 의 ACID 트랜잭션 커밋으로 해결 가능합니다. 최종 참여자 지원(LPS, last participant support) 를 활용하면 메시지 처리가 끝나 DB 에 저장됐음을 확인한 이후에 큐에서 메시지가 삭제됩니다.

# 5. 브로드캐스팅

  이벤트 기반 아키텍처는 메시지를 누가 받든, 그 메시지로 무슨 일을 하든 상관없이 이벤트를 브로트캐스트할 수 있습니다. 따라서 브로트캐스팅은 여러 이벤트 프로세서를 가장 높은 수준으로 디커플링하는 수단이며, 최종 일관성, 복잡한 이벤트 처리 등 다양한 쓰임새를 지녔습니다.

# 6. 요청-응답

  이벤트 기반 아키텍처에서 동기 요청이 필요한 경우가 있습니다. 이는 요청-응답 메시징(request-response messaging) 방식으로 수행합니다. 프로듀서가 요청 큐에 이벤트를 비동기 전송한 후 프로듀서는 차단 대기 상태가 됩니다. 메시지 컨슈머가 이벤트 메시지를 받아 처리한 후 응답 큐에 응답을 보내면 이벤트 프로듀서는 응답 데이터가 포함된 메시지를 수신합니다.

![image-20240218214110683](images/14장 이벤트 기반 아키텍처 스타일/image-20240218214110683.png)

  구현 방법은 크게 2가지로, 상관 ID 와 임시 큐가 있습니다. 상관 ID 는 큐 헤더에 ID 값을 넣어서 응답을 구분하는 것이고, 임시 큐는 요청에 대한 임시 큐를 만드는 것입니다. 임시 큐를 사용하면 기술적으로 단순해지지만 매번 요청할 때마다 임시 큐를 생성/폐기해야 하므로 성능과 응답성이 떨어집니다. 따라서 대체로 상관 ID 방법이 권장됩니다.

# 7. 요청 기반이냐, 이벤트 기반이냐

  아래는 이벤트 기반 모델의 장단점입니다.

![image-20240218214401956](images/14장 이벤트 기반 아키텍처 스타일/image-20240218214401956.png)

# Q

1. 중재자 토폴로지가 동적인 처리를 선언적으로 모델링하기 어려운 이유?
   - 중재자 토폴로지는 선언적 구문을 통해 표현되는데, 선언적 구문으로는 동적인 요소들을 표현하는 것은 어렵습니다. 이벤트의 모든 가능한 경로와 변환을 미리 정의해야 하기 때문입니다. 
2. 최종 참여자 지원이란(LPS)

