# 2. 토폴로지

![image-20240306000006660](images/17장_마이크로서비스_아키텍처_스타일/image-20240306000006660.png)

  마이크로서비스는 단일 목적만 가지기 때문에 다른 분산 아키텍처보다 서비스 규모가 훨씬 작습니다.

# 3. 분산

  다수의 애플리케이션을 관리할 때 네트워크 대역폭, 메모리, 디스크 공간 등 리소스를 공유하는 데 문제가 생길 수 있습니다. 공유때문에 불거지는 문제는 각 서비스를 자체 프로세스로 분리하면서 해결할 수 있습니다. 마이크로서비스는 분산 속성 탓에 성능은 다소 부정적입니다.

# 4. 경계 콘텍스트

  마이크로서비스의 근본 철학은 경계 콘텍스트 개념입니다. 클래스, 컴포넌트, DB 스키마 등 애플리케이션 작동에 필요한 모든 것이 각 서비스로 들어가며, 커플링을 피하기 위해 중복을 감수합니다. 

## 4.1 세분도

  마이크로서비스에서 서비스를 너무 잘게 나눠도 문제가 생길 수 있습니다. 이를 위한 몇가지 가이드라인이 있습니다.

**목적**

  마이크로서비스 아키텍처 스타일의 본래 의도인 도메인으로 나눕니다. 

**트랜잭션**

  여러 엔티티가 함꼐 개입하여 작동되는 트랜잭션으로 경계를 나눕니다. 

**코레오그래피**

  통신 오버헤드를 고려해 서비스를 뭉쳐야 할 수도 있습니다.

## 4.2 데이터 격리

  마이크로서비스는 경계 콘텍스트 개념에 따라 데이터를 격리해야 하므로 어떻게 데이터를 분산시킬지 결정해야 합니다. 

# 5. API 레이어

  API 레이어는 프록시를 경유하여 간접화하거나 네이밍 서비스 같은 운영 장치에 물려서 작업하기 좋은 위치에 있기 때문에 마이크로서비스에 많이 쓰입니다. API 레이어는 중재자나 오케스트레이션 도구로 사용하지 말아야 하며 모든 비즈니스 로직은 경계 콘텍스트 내부에서 일어나야 합니다.

# 6. 운영 재사용

  마이크로서비스는 커플링보다 복제를 선호합니다. 따라서 모니터링, 로깅, 회로 차단기 등 커플링이 중요한 운영 관심사는 사이드카 패턴으로 해결합니다. 

![image-20240306001354037](images/17장_마이크로서비스_아키텍처_스타일/image-20240306001354037.png)

  위 그림과 같이 공통 운영 관심사를 각 서비스마다 별도의 컴포넌트에 두고 해당 팀이나 공유 인프라팀이 관리합니다.

![image-20240306001526242](images/17장_마이크로서비스_아키텍처_스타일/image-20240306001526242.png)

  또한 위 그림과 같이 서비스 메시를 구축해서 모든 마이크로서비스에 대해 일관된 운영 인터페이스를 제공할 수도 있습니다.

# 8. 통신

  마이크로서비스 아키텍서는 프로토콜 인지 이종 간 상호 운용성(protocol-aware heterogeneous interaperability) 을 활용합니다.

- 프로토콜 인지 : 각 서비스가 다른 서비스를 호출할 때 어떤 프로토콜을 사용할지 알아야 합니다.
- 이종 : 마이크로서비스는 각 서비스마다 구현 기술 스택과 플랫폼이 다를 수 있습니다.
- 상호 운용성 : 여러 서비스가 서로 호출한다는 뜻입니다.

## 8.1 코레오그래피와 오케스트레이션

​    코레오그래피는 중앙의 중재자가 따로 없이 자신의 필요에 따라 다른 서비스를 호출합니다.

![image-20240306003156579](images/17장_마이크로서비스_아키텍처_스타일/image-20240306003156579.png)

  위 그림처럼 유저의 위시리스트를 가져올 때, 필요한 정보가 위시리스트 서비스에 다 있는 건 아니어서 고객분석데이터 서비스를 호출해 모자란 정보를 보충합니다.

![image-20240306003307747](images/17장_마이크로서비스_아키텍처_스타일/image-20240306003307747.png)

또는 복잡한 처리가 필요하다면 위 그림처럼 오케스트레이션 서비스를 사용할 수도 있습니다. 이러면 서비스 간 커플링은 발생하지만 한 서비스가 조정 작업을 전담하므로 다른 서비스는 거의 영향을 받지 않습니다. 

## 8.2 트랜잭션과 사가

  마이크로서비스에서 여러 서비스에 걸친 트랜잭션의 조정이나 데이터베이스의 디커플링이 문제로 대두됩니다. 서비스 경계를 넘나드는 트랜잭션은 디커플링 원칙에 위배되기 때문입니다. 여러 서비스에 걸쳐 트랜잭션을 엮어야 한다면 설계를 지나치게 세분화한 것일 수 있습니다. 

  하지만 두 서비스가 완전히 다르지면 한 트랜잭션으로 묶여야 할 때가 있는데, 이럴 때는 사가 패턴을 사용할 수 있습니다.

![image-20240306003731399](images/17장_마이크로서비스_아키텍처_스타일/image-20240306003731399.png)

  예를 들어 위 그림처럼 두 개의 서비스를 조회하는 로직이 있을 때, 첫번째는 성공했지만 두벉매 파트가 실패한 경우 중재자는 지금까지 성공한 모든 트랜잭션 파트에게 과거에 처리했던 내용을 undo 하라는 요청을 보냅니다. 이런 종류의 트랜잭션 조정을 보상 트랜젝션 프레임워크라고 합니다. 이 패턴은 전체가 다 성공했다고 중재자가 알릴 때까지 중재자로부터 받은 각 요청은 보류 상태로 둡니다. 